//o(n)空间复杂度，o(nlogn)时间复杂度方法
class Solution {
public:
	void wiggleSort(vector<int>& nums) {
		vector<int> tmp = nums;
		sort(tmp.begin(), tmp.end());
		//int begin=0,end=nums.size()-1;
		int j = (nums.size() + 1) / 2 - 1;//由于先放小的数，所以可能小的数要比大的数多1，所以总数是奇数个的时候，应该前半段比后半段多1
		int k = nums.size() - 1;
		//不能采用排序后，最小的放第一个，最大的放第二个，第二小的放第三个，第二大的放第四个，因为会有相等的数字被安排在相邻位置，比如1,1,2,2,3,3就会变成1,3,1,3,2，2
		for (int i = 0; i<nums.size(); ++i)
		{
			nums[i] = i & 1 ? tmp[k--] : tmp[j--];
		}
	}
};


//解法II O(n)时间复杂度 + O(1)空间复杂度解法：
//1. 使用O(n)时间复杂度的quickSelect算法，从未经排序的数组nums中选出中位数mid
//2. 参照解法I的思路，将nums数组的下标x通过函数idx()从[0, 1, 2, ..., n - 1, n] 映射到[1, 3, 5, ..., 0, 2, 4, ...]，得到新下标ix
//3. 以中位数mid为界，将大于mid的元素排列在ix的较小部分，而将小于mid的元素排列在ix的较大部分。
//遍历数组的时候如果当前的数大于中位数就将其从左往右放奇数位置, 如果小于中位数就将其从右往左放在偶数位置

//（n | 1）与n是偶数还是奇数有关。当n为偶数时，我们只需要nums[1 + 2 i％（n + 1）]
//而不是nums[1 + 2 i％（n | 1）]; 当n为奇数时，我们需要nums[1 + 2 i％n]而不是nums[1 + 2 i％（n | 1）]。
//要将两种情况组合在一起（n为偶数或奇数），我们可以简单地使用一个公式nums[1 + 2 * i％（n | 1）]。